{"version":3,"file":"singleton-interval.decorator.js","sourceRoot":"","sources":["singleton-interval.decorator.ts"],"names":[],"mappings":";;;AAQA,8CAgCC;AAxCD,6EAGsC;AAEtC;;GAEG;AACH,SAAgB,iBAAiB,CAC/B,YAAoB,EACpB,OAAkC;IAElC,OAAO,CACL,MAAW,EACX,WAA4B,EAC5B,UAA8B,EAC9B,EAAE;QACF,MAAM,UAAU,GAAG,WAAW,CAAC,QAAQ,EAAE,CAAC;QAC1C,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC,WAAW,CAAC,IAAI,IAAI,UAAU,EAAE,CAAC;QACvD,8DAA8D;QAC9D,qDAAwB,CAAC,kBAAkB,CAAC,IAAI,CAAC;YAC/C,WAAW,EAAE,MAAM,CAAC,WAAW;YAC/B,GAAG;YACH,cAAc,EAAE,UAAU,CAAC,KAAM;YACjC,QAAQ,EAAE,YAAY;YACtB,OAAO;SACR,CAAC,CAAC;QACH,qCAAqC;QACrC,MAAM,OAAO,GAAG,IAAI,qDAAwB,CAC1C,GAAG,EACH,UAAU,CAAC,KAAM,EACjB,YAAY,EACZ,OAAO,CACR,CAAC;QACF,4DAA4D;QAC5D,UAAU,CAAC,KAAK,GAAG,UAAU,GAAG,IAAW;YACzC,OAAO,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACjC,CAAC,CAAC;QACF,OAAO,UAAU,CAAC;IACpB,CAAC,CAAC;AACJ,CAAC;AAED,kEAAkE;AAClE,WAAiB,iBAAiB;IACnB,8BAAY,GAAG,qDAAwB,CAAC,YAAY,CAAC;IACrD,gCAAc,GAAG,qDAAwB,CAAC,cAAc,CAAC;IACzD,gCAAc,GAAG,qDAAwB,CAAC,cAAc,CAAC;IACzD,qCAAmB,GAC9B,qDAAwB,CAAC,mBAAmB,CAAC;IACpC,0CAAwB,GACjC,qDAAwB,CAAC,wBAAwB,CAAC;AACtD,CAAC,EARgB,iBAAiB,iCAAjB,iBAAiB,QAQjC;AAED,gCAAgC;AAChC,2EAQsC;AAPpC,yIAAA,2BAA2B,OAAA;AAC3B,qIAAA,uBAAuB,OAAA;AAGvB,gIAAA,kBAAkB,OAAA;AAClB,6HAAA,eAAe,OAAA;AACf,0HAAA,YAAY,OAAA","sourcesContent":["import {\n  SingletonIntervalService,\n  SingletonIntervalOptions,\n} from \"./singleton-interval.service\";\n\n/**\n * Decorator shorthand for SingletonIntervalService\n */\nexport function SingletonInterval(\n  milliseconds: number,\n  options?: SingletonIntervalOptions\n): MethodDecorator {\n  return (\n    target: any,\n    propertyKey: string | symbol,\n    descriptor: PropertyDescriptor\n  ) => {\n    const methodName = propertyKey.toString();\n    const key = `${target.constructor.name}.${methodName}`;\n    // Register decorator‚Äêdefined interval for registry processing\n    SingletonIntervalService.pendingDefinitions.push({\n      targetClass: target.constructor,\n      key,\n      originalMethod: descriptor.value!,\n      interval: milliseconds,\n      options,\n    });\n    // Create service to manage execution\n    const service = new SingletonIntervalService(\n      key,\n      descriptor.value!,\n      milliseconds,\n      options\n    );\n    // Override the method so it always runs through the service\n    descriptor.value = function (...args: any[]) {\n      return service.run(this, args);\n    };\n    return descriptor;\n  };\n}\n\n// Preserve static references for backward compatibility and tests\nexport namespace SingletonInterval {\n  export const eventEmitter = SingletonIntervalService.eventEmitter;\n  export const globalMutexMap = SingletonIntervalService.globalMutexMap;\n  export const initEmittedFor = SingletonIntervalService.initEmittedFor;\n  export const intervalDefinitions =\n    SingletonIntervalService.intervalDefinitions;\n  export let isMicroserviceResponsive =\n    SingletonIntervalService.isMicroserviceResponsive;\n}\n\n// Re-export types and utilities\nexport {\n  INTERVAL_TERMINATION_FACTOR,\n  SingletonIntervalEvents,\n  SingletonIntervalDefinition,\n  SingletonIntervalOptions,\n  IntervalTerminated,\n  getIntervalName,\n  getEventName,\n} from \"./singleton-interval.service\";\n"]}