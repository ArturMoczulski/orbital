{"version":3,"file":"singleton-interval.service.js","sourceRoot":"","sources":["singleton-interval.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger, LoggerService } from \"@nestjs/common\";\nimport { EventEmitter2 } from \"@nestjs/event-emitter\";\nimport { SchedulerRegistry } from \"@nestjs/schedule\";\nimport { Mutex } from \"async-mutex\";\nimport humanizeDuration from \"humanize-duration\";\n\nexport enum SingletonIntervalEvents {\n  Init = \"Init\",\n  Started = \"Started\",\n  AlreadyRunning = \"AlreadyRunning\",\n  ConditionsNotMet = \"ConditionsNotMet\",\n  Terminated = \"Terminated\",\n  Error = \"Error\",\n  Success = \"Success\",\n  LongRunning = \"LongRunning\",\n  Finish = \"Finish\",\n  MicroservicesUnresponsive = \"MicroservicesUnresponsive\",\n}\n\nexport type SingletonIntervalOptions = {\n  finally?: () => Promise<void>;\n  onError?: (error: Error) => Promise<void>;\n  onTerminate?: () => Promise<void>;\n  conditions?: Record<string, () => Promise<boolean>>;\n  microservices?: string[];\n};\n\nexport type SingletonIntervalDefinition = {\n  name: string;\n  interval: number;\n  finally?: () => Promise<void>;\n  onError?: (error: Error) => Promise<void>;\n  onTerminate?: () => Promise<void>;\n  conditions?: Record<string, () => Promise<boolean>>;\n  microservices?: string[];\n};\n\nexport class IntervalTerminated extends Error {\n  constructor(intervalName: string, interval: number) {\n    super(\n      `${intervalName}: ❌ terminated due to exceeding time limit of ${\n        SingletonIntervalService.INTERVAL_TERMINATION_FACTOR * interval\n      } ms (${SingletonIntervalService.INTERVAL_TERMINATION_FACTOR} x interval)`\n    );\n  }\n}\n\nexport function getIntervalName(className: string, methodName: string): string {\n  return `${className}.${methodName}`;\n}\n\nexport function getEventName(\n  name: string,\n  event: SingletonIntervalEvents\n): string {\n  return `${name}.${event}`;\n}\n\nexport class SingletonIntervalService {\n  /** Pending registrations until schedulerRegistry is set */\n  private static pendingRegistrations: Array<{\n    service: SingletonIntervalService;\n    context: any;\n  }> = [];\n  /** Pending decorator definitions until instances are discovered */\n  public static pendingDefinitions: Array<{\n    targetClass: any;\n    key: string;\n    originalMethod: (...args: any[]) => Promise<any>;\n    interval: number;\n    options?: SingletonIntervalOptions;\n  }> = [];\n  public static eventEmitter?: EventEmitter2;\n  public static schedulerRegistry?: SchedulerRegistry;\n\n  /**\n   * Flush any intervals queued while schedulerRegistry was unset.\n   */\n  public static flushPendingRegistrations(): void {\n    for (const { service, context } of this.pendingRegistrations) {\n      service.registerWithScheduler(context);\n    }\n    this.pendingRegistrations = [];\n  }\n\n  /** Set Nest’s SchedulerRegistry for dynamic interval registration. Flush pending registrations. */\n  public static setSchedulerRegistry(registry: SchedulerRegistry) {\n    this.schedulerRegistry = registry;\n  }\n  public static globalMutexMap = new Map<string, Mutex>();\n  public static initEmittedFor = new Set<string>();\n  public static intervalDefinitions = new Map<\n    string,\n    { name: string; interval: number }\n  >();\n  public static lastConditionsNotMetLogTime = new Map<string, number>();\n  public static appStartTimeMs = Date.now();\n  public static initialSuppressMs = 45 * 1000;\n  public static isMicroserviceResponsive?: (name: string) => Promise<boolean>;\n  public static lastInactiveLogTime = new Map<string, number>();\n  public static INACTIVE_LOG_THROTTLE_MS = 45 * 1000;\n  public static NOT_MET_LOG_THROTTLE_MS = 60 * 1000;\n  public static SHOULD_THROTTLE_NOT_MET_LOGS = true;\n  public static CONDITION_TIMEOUT_MS = 15 * 1000;\n  public static INTERVAL_TERMINATION_FACTOR = 20;\n\n  private readonly uniqueKey: string;\n  private readonly originalMethod: (...args: any[]) => Promise<any>;\n  private readonly intervalMs: number;\n  private readonly options?: SingletonIntervalOptions;\n  private readonly logger: LoggerService;\n  private readonly mutex: Mutex;\n  private readonly combinedConditions: Record<string, () => Promise<boolean>>;\n  private enabledFlag = true;\n\n  public get enabled(): boolean {\n    return this.enabledFlag;\n  }\n\n  public set enabled(value: boolean) {\n    this.enabledFlag = value;\n  }\n\n  constructor(\n    uniqueKey: string,\n    originalMethod: (...args: any[]) => Promise<any>,\n    intervalMs: number,\n    options?: SingletonIntervalOptions\n  ) {\n    this.uniqueKey = uniqueKey;\n    this.originalMethod = originalMethod;\n    this.intervalMs = intervalMs;\n    this.options = options;\n    this.logger = new Logger(this.uniqueKey);\n\n    if (!SingletonIntervalService.globalMutexMap.has(this.uniqueKey)) {\n      SingletonIntervalService.globalMutexMap.set(this.uniqueKey, new Mutex());\n    }\n    this.mutex = SingletonIntervalService.globalMutexMap.get(this.uniqueKey)!;\n\n    if (!SingletonIntervalService.intervalDefinitions.has(this.uniqueKey)) {\n      SingletonIntervalService.intervalDefinitions.set(this.uniqueKey, {\n        name: this.uniqueKey,\n        interval: intervalMs,\n      });\n    }\n\n    this.combinedConditions = this.buildConditions();\n    SingletonIntervalService.lastConditionsNotMetLogTime.set(\n      this.uniqueKey,\n      Date.now()\n    );\n  }\n\n  public async run(context: any, args: any[]): Promise<void> {\n    const emitter = SingletonIntervalService.eventEmitter;\n    const release = await this.preRun(emitter);\n    if (!release) return;\n    await this.executeWithTimeoutAndEvents(context, args, release, emitter);\n  }\n\n  /**\n   * Dynamically register this interval via Nest’s SchedulerRegistry.\n   * Requires SchedulerRegistry set via setSchedulerRegistry().\n   */\n  public registerWithScheduler(context: any): void {\n    const reg = SingletonIntervalService.schedulerRegistry;\n    if (!reg) {\n      // Queue until schedulerRegistry is configured (avoid duplicates)\n      if (\n        !SingletonIntervalService.pendingRegistrations.some(\n          (r) => r.service === this\n        )\n      ) {\n        SingletonIntervalService.pendingRegistrations.push({\n          service: this,\n          context,\n        });\n      }\n      return;\n    }\n    // Prevent duplicate scheduling if already registered\n    if ((reg as any).getIntervals().includes(this.uniqueKey)) {\n      this.logger.warn(\n        `Interval '${this.uniqueKey}' already registered, skipping duplicate.`\n      );\n      return;\n    }\n    const timer = setInterval(() => this.run(context, []), this.intervalMs);\n    try {\n      this.logger.log(`Registering singleton interval: ${this.uniqueKey}`);\n      (reg as any).addInterval(this.uniqueKey, timer);\n    } catch (err) {\n      this.logger.warn(\n        `Interval '${this.uniqueKey}' already registered, skipping duplicate.`\n      );\n    }\n  }\n\n  private buildConditions(): Record<string, () => Promise<boolean>> {\n    const conditions: Record<string, () => Promise<boolean>> = {};\n    if (this.options?.conditions) {\n      Object.assign(conditions, this.options.conditions);\n    }\n    if (this.options?.microservices) {\n      for (const name of this.options.microservices) {\n        conditions[`Microservice ${name} available`] = async () => {\n          if (!SingletonIntervalService.isMicroserviceResponsive) {\n            this.logger.error(\n              `[${this.uniqueKey}] No health-check provided for '${name}', treating as down.`\n            );\n            return false;\n          }\n          try {\n            return await SingletonIntervalService.isMicroserviceResponsive(\n              name\n            );\n          } catch {\n            this.logger.error(\n              `[${this.uniqueKey}] Error checking microservice '${name}'.`\n            );\n            return false;\n          }\n        };\n      }\n    }\n    return conditions;\n  }\n\n  private async checkConditions(): Promise<string[]> {\n    const notMet: string[] = [];\n    for (const [name, fn] of Object.entries(this.combinedConditions)) {\n      let timeoutHandle: ReturnType<typeof setTimeout>;\n      try {\n        const result = await Promise.race([\n          fn().catch(() => false),\n          new Promise<boolean>((_, reject) => {\n            timeoutHandle = setTimeout(\n              () => reject(new Error(`Condition '${name}' timed out`)),\n              SingletonIntervalService.CONDITION_TIMEOUT_MS\n            );\n          }),\n        ]);\n        if (!result) notMet.push(name);\n      } catch {\n        notMet.push(name);\n      } finally {\n        clearTimeout(timeoutHandle!);\n      }\n    }\n    return notMet;\n  }\n\n  private logConditionsNotMet(notMet: string[]): void {\n    const now = Date.now();\n    if (\n      now - SingletonIntervalService.appStartTimeMs <\n      SingletonIntervalService.initialSuppressMs\n    ) {\n      const nonMicro = notMet.filter((n) => !n.startsWith(\"Microservice \"));\n      if (nonMicro.length) {\n        this.logger.warn(`Conditions not met: [${nonMicro.join(\", \")}].`);\n      }\n      return;\n    }\n    const lastLog = SingletonIntervalService.lastConditionsNotMetLogTime.get(\n      this.uniqueKey\n    )!;\n    if (\n      !SingletonIntervalService.SHOULD_THROTTLE_NOT_MET_LOGS ||\n      now - lastLog > SingletonIntervalService.NOT_MET_LOG_THROTTLE_MS\n    ) {\n      this.logger.warn(\n        `Conditions not met: [${notMet.join(\", \")}]. ${humanizeDuration(\n          this.intervalMs\n        )} interval.`\n      );\n      SingletonIntervalService.lastConditionsNotMetLogTime.set(\n        this.uniqueKey,\n        now\n      );\n    }\n  }\n\n  private async handleConditionsStage(): Promise<boolean> {\n    const emitter = SingletonIntervalService.eventEmitter;\n    const notMet = await this.checkConditions();\n    if (!notMet.length) return true;\n    this.logConditionsNotMet(notMet);\n    emitter?.emit(\n      getEventName(this.uniqueKey, SingletonIntervalEvents.ConditionsNotMet),\n      { intervalName: this.uniqueKey, failedConditions: notMet }\n    );\n    const unresp = notMet.filter((c) => c.startsWith(\"Microservice \"));\n    if (unresp.length) {\n      emitter?.emit(\n        getEventName(\n          this.uniqueKey,\n          SingletonIntervalEvents.MicroservicesUnresponsive\n        ),\n        { intervalName: this.uniqueKey, unresponsive: unresp }\n      );\n    }\n    return false;\n  }\n\n  private emitInit(): void {\n    const emitter = SingletonIntervalService.eventEmitter;\n    if (!SingletonIntervalService.initEmittedFor.has(this.uniqueKey)) {\n      emitter?.emit(\n        getEventName(this.uniqueKey, SingletonIntervalEvents.Init),\n        { intervalName: this.uniqueKey, intervalMs: this.intervalMs }\n      );\n      SingletonIntervalService.initEmittedFor.add(this.uniqueKey);\n    }\n  }\n\n  private handleAlreadyRunning(): boolean {\n    if (this.mutex.isLocked()) {\n      SingletonIntervalService.eventEmitter?.emit(\n        getEventName(this.uniqueKey, SingletonIntervalEvents.AlreadyRunning),\n        { intervalName: this.uniqueKey }\n      );\n      return true;\n    }\n    return false;\n  }\n\n  private handleDisabled(): void {\n    const now = Date.now();\n    const lastLog =\n      SingletonIntervalService.lastInactiveLogTime.get(this.uniqueKey) || 0;\n    if (now - lastLog > SingletonIntervalService.INACTIVE_LOG_THROTTLE_MS) {\n      this.logger.warn(`Interval '${this.uniqueKey}' is disabled.`);\n      SingletonIntervalService.lastInactiveLogTime.set(this.uniqueKey, now);\n    }\n  }\n\n  private async preRun(\n    emitter?: EventEmitter2\n  ): Promise<(() => void) | undefined> {\n    this.emitInit();\n    if (this.enabled) {\n      if (this.handleAlreadyRunning()) {\n        return undefined;\n      }\n      const release = await this.acquireLock();\n      if (!release) {\n        return undefined;\n      }\n      if (!(await this.handleConditionsStage())) {\n        release();\n        return undefined;\n      }\n      emitter?.emit(\n        getEventName(this.uniqueKey, SingletonIntervalEvents.Started),\n        { intervalName: this.uniqueKey }\n      );\n      return release;\n    } else {\n      this.handleDisabled();\n      return undefined;\n    }\n  }\n\n  private async handleFinally(): Promise<void> {\n    if (this.options?.finally) {\n      try {\n        await this.options.finally();\n      } catch (e) {\n        this.logger.error(`Error in finally handler: ${e}`);\n      }\n    }\n  }\n\n  private async handleError(err: Error): Promise<void> {\n    if (this.options?.onError) {\n      try {\n        await this.options.onError(err);\n      } catch (e) {\n        this.logger.error(`Error in onError handler: ${e}`);\n      }\n    }\n    SingletonIntervalService.eventEmitter?.emit(\n      getEventName(this.uniqueKey, SingletonIntervalEvents.Error),\n      { intervalName: this.uniqueKey, error: err }\n    );\n  }\n\n  private async handleTerminate(err: Error): Promise<void> {\n    if (this.options?.onTerminate) {\n      try {\n        await this.options.onTerminate();\n      } catch (e) {\n        this.logger.error(`Error in onTerminate handler: ${e}`);\n      }\n    }\n    SingletonIntervalService.eventEmitter?.emit(\n      getEventName(this.uniqueKey, SingletonIntervalEvents.Terminated),\n      { intervalName: this.uniqueKey, error: err }\n    );\n  }\n\n  private async acquireLock(): Promise<(() => void) | undefined> {\n    try {\n      return await this.mutex.acquire();\n    } catch (e) {\n      this.logger.error(`Failed to acquire lock: ${e}`);\n      return undefined;\n    }\n  }\n\n  private async executeWithTimeoutAndEvents(\n    context: any,\n    args: any[],\n    release: () => void,\n    emitter?: EventEmitter2\n  ): Promise<void> {\n    let timer: ReturnType<typeof setTimeout>;\n    const start = Date.now();\n    try {\n      const timeout = new Promise<void>((_, rej) => {\n        timer = setTimeout(\n          () => rej(new IntervalTerminated(this.uniqueKey, this.intervalMs)),\n          SingletonIntervalService.INTERVAL_TERMINATION_FACTOR * this.intervalMs\n        );\n      });\n      await Promise.race([this.originalMethod.apply(context, args), timeout]);\n      emitter?.emit(\n        getEventName(this.uniqueKey, SingletonIntervalEvents.Success),\n        { intervalName: this.uniqueKey }\n      );\n    } catch (err) {\n      if (err instanceof IntervalTerminated) {\n        await this.handleTerminate(err);\n      } else {\n        await this.handleError(err as Error);\n      }\n    } finally {\n      clearTimeout(timer!);\n      release();\n      const elapsed = Date.now() - start;\n      if (elapsed > this.intervalMs) {\n        this.logger.warn(`Long run: ${elapsed}ms`);\n        emitter?.emit(\n          getEventName(this.uniqueKey, SingletonIntervalEvents.LongRunning),\n          { intervalName: this.uniqueKey, elapsed }\n        );\n      }\n      await this.handleFinally();\n      emitter?.emit(\n        getEventName(this.uniqueKey, SingletonIntervalEvents.Finish),\n        { intervalName: this.uniqueKey, elapsed }\n      );\n    }\n  }\n}\nexport const INTERVAL_TERMINATION_FACTOR =\n  SingletonIntervalService.INTERVAL_TERMINATION_FACTOR;\n"]}