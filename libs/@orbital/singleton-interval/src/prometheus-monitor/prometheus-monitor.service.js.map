{"version":3,"file":"prometheus-monitor.service.js","sourceRoot":"","sources":["prometheus-monitor.service.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,2CAA4D;AAC5D,mEAA2D;AAC3D,6CAA6C;AAC7C,8EAIuC;AAEvC,MAAM,mBAAmB,GAAkC;IACzD,IAAI,EAAE,CAAC;IACP,IAAI,EAAE,CAAC;IACP,OAAO,EAAE,CAAC;IACV,IAAI,EAAE,CAAC;IACP,MAAM,EAAE,CAAC;IACT,OAAO,EAAE,CAAC;IACV,OAAO,EAAE,CAAC;IACV,KAAK,EAAE,CAAC;IACR,kBAAkB,EAAE,CAAC;IACrB,yBAAyB,EAAE,CAAC;CAC7B,CAAC;AAIK,IAAM,wBAAwB,gCAA9B,MAAM,wBAAwB;IAGnC,YACmB,iBAA2C,EAI5D,oBAA4C,EAI5C,WAAqC,EAIrC,UAAkC;QAZjB,sBAAiB,GAAjB,iBAAiB,CAA0B;QAI3C,yBAAoB,GAApB,oBAAoB,CAAO;QAI3B,gBAAW,GAAX,WAAW,CAAS;QAIpB,eAAU,GAAV,UAAU,CAAO;QAfnB,WAAM,GAAG,IAAI,eAAM,CAAC,0BAAwB,CAAC,IAAI,CAAC,CAAC;IAgBjE,CAAC;IAEG,qBAAqB;;QAC1B,6CAA6C;QAC7C,MAAM,MAAM,GAAqB,IAAI,CAAC,iBAAiB,CAAC,eAAe,EAAE,CAAC;QAE1E,KAAK,MAAM,IAAI,IAAI,MAAM,EAAE,CAAC;YAC1B,MAAM,EAAE,GAAG,EAAE,YAAY,EAAE,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,CAAC;YAEzD,uDAAuD;YACvD,+CAA+C;YAC/C,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAC3B,EAAE,aAAa,EAAE,YAAY,EAAE,EAC/B,YAAY,CACb,CAAC;YAEF,kEAAkE;YAClE,0DAA0D;YAC1D,IAAI,YAAY,GAAG,CAAC,EAAE,CAAC;gBACrB,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,EAAE,aAAa,EAAE,YAAY,EAAE,CAAC,CAAC;YACxD,CAAC;YAED,2DAA2D;YAC3D,MAAM,IAAI,GAAG,MAAA,mBAAmB,CAAC,MAAM,CAAC,mCAAI,CAAC,CAAC,CAAC;YAC/C,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,aAAa,EAAE,YAAY,EAAE,EAAE,IAAI,CAAC,CAAC;QAC7D,CAAC;IACH,CAAC;CACF,CAAA;AA5CY,4DAAwB;mCAAxB,wBAAwB;IAFpC,IAAA,eAAM,GAAE;IACR,IAAA,mBAAU,GAAE;IAQR,WAAA,IAAA,gCAAY,EAAC,+BAA+B,CAAC,CAAA;IAI7C,WAAA,IAAA,gCAAY,EAAC,qBAAqB,CAAC,CAAA;IAInC,WAAA,IAAA,gCAAY,EAAC,qBAAqB,CAAC,CAAA;qCAXA,qDAAwB,sBAIrB,mBAAK,oBAAL,mBAAK,oDAId,qBAAO,oBAAP,qBAAO,oDAIR,mBAAK,oBAAL,mBAAK;GAhBzB,wBAAwB,CA4CpC","sourcesContent":["import { Global, Injectable, Logger } from \"@nestjs/common\";\nimport { InjectMetric } from \"@willsoto/nestjs-prometheus\";\nimport { Counter, Gauge } from \"prom-client\";\nimport {\n  IntervalsRegistryService,\n  IntervalState,\n  IntervalStatus,\n} from \"../intervals-registry.service\";\n\nconst INTERVAL_STATE_CODE: Record<IntervalState, number> = {\n  INIT: 0,\n  LATE: 1,\n  RUNNING: 2,\n  SLOW: 3,\n  JAMMED: 4,\n  HEALTHY: 5,\n  STOPPED: 6,\n  ERROR: 7,\n  CONDITIONS_NOT_MET: 8,\n  MICROSERVICES_UNAVAILABLE: 9,\n};\n\n@Global()\n@Injectable()\nexport class PrometheusMonitorService {\n  private readonly logger = new Logger(PrometheusMonitorService.name);\n\n  constructor(\n    private readonly intervalsRegistry: IntervalsRegistryService,\n\n    // A gauge for the \"last run duration\" in ms\n    @InjectMetric(\"interval_last_run_duration_ms\")\n    private readonly lastRunDurationGauge: Gauge,\n\n    // (Optional) a counter for the total runs of each interval\n    @InjectMetric(\"interval_runs_total\")\n    private readonly runsCounter: Counter,\n\n    // (Optional) a gauge for numeric state code\n    @InjectMetric(\"interval_state_code\")\n    private readonly stateGauge: Gauge\n  ) {}\n\n  public updateIntervalMetrics(): void {\n    // Get the latest snapshot from your registry\n    const report: IntervalStatus[] = this.intervalsRegistry.getStatusReport();\n\n    for (const item of report) {\n      const { key: intervalName, status, lastDuration } = item;\n\n      // 1) Update the gauge with the last run duration (ms).\n      // Prometheus will store this as a time-series.\n      this.lastRunDurationGauge.set(\n        { interval_name: intervalName },\n        lastDuration\n      );\n\n      // 2) (Optional) If a new run just occurred, increment the counter\n      // so you can also see total runs over time (if you like).\n      if (lastDuration > 0) {\n        this.runsCounter.inc({ interval_name: intervalName });\n      }\n\n      // 3) (Optional) Store a numeric code for the current state\n      const code = INTERVAL_STATE_CODE[status] ?? -1;\n      this.stateGauge.set({ interval_name: intervalName }, code);\n    }\n  }\n}\n"]}