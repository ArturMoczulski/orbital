{"version":3,"file":"intervals-registry.service.js","sourceRoot":"","sources":["intervals-registry.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Global, Injectable, Logger, OnModuleInit } from \"@nestjs/common\";\nimport { DiscoveryService } from \"@nestjs/core\";\nimport { EventEmitter2, OnEvent } from \"@nestjs/event-emitter\";\nimport { SchedulerRegistry } from \"@nestjs/schedule\";\nimport {\n  SingletonIntervalDefinition,\n  SingletonIntervalEvents,\n  SingletonIntervalService,\n} from \"./singleton-interval.service\";\n\n/** Represents the current state of an interval's latest run. */\nexport enum IntervalState {\n  INIT = \"INIT\",\n  LATE = \"LATE\",\n  RUNNING = \"RUNNING\",\n  SLOW = \"SLOW\",\n  JAMMED = \"JAMMED\",\n  HEALTHY = \"HEALTHY\",\n  STOPPED = \"STOPPED\",\n  ERROR = \"ERROR\",\n  CONDITIONS_NOT_MET = \"CONDITIONS_NOT_MET\",\n  MICROSERVICES_UNAVAILABLE = \"MICROSERVICES_UNAVAILABLE\",\n}\n\n/**\n * Internal data we track about each unique interval.\n */\nexport interface IntervalRecord {\n  intervalMs: number;\n  createTime: number;\n  lastStart: number;\n  lastDuration: number; // in ms; 0 if never completed\n  locked: boolean; // whether the interval is currently running\n  lastError?: Error;\n  notMetConditions?: string[];\n  microservicesUnavailable?: boolean;\n}\n\n/**\n * A snapshot of an interval's status, for external reporting.\n */\nexport interface IntervalStatus {\n  key: string; // e.g. \"MyService.myMethod\"\n  status: IntervalState;\n  locked: boolean;\n  lastDuration: number;\n  lastError?: Error;\n  notMetConditions?: string[];\n  microservicesUnavailable?: boolean;\n}\n\n/**\n * This service listens to the events emitted by the SingletonInterval decorator.\n * Whenever a method starts, finishes, errors, etc., we update our in-memory registry\n * so we can produce a status report later.\n */\n@Global()\n@Injectable()\nexport class IntervalsRegistryService implements OnModuleInit {\n  constructor(\n    private readonly eventEmitter: EventEmitter2,\n    private readonly schedulerRegistry: SchedulerRegistry,\n    private readonly discoveryService: DiscoveryService\n  ) {}\n\n  private readonly logger: Logger = new Logger(IntervalsRegistryService.name);\n\n  onModuleInit(): void {\n    // Initialize event emitter and scheduler\n    SingletonIntervalService.eventEmitter = this.eventEmitter;\n    SingletonIntervalService.setSchedulerRegistry(this.schedulerRegistry);\n\n    // Process pending decorator-defined intervals\n    const wrappers = [\n      ...this.discoveryService.getProviders(),\n      ...this.discoveryService.getControllers(),\n    ];\n    for (const def of SingletonIntervalService.pendingDefinitions) {\n      for (const wrapper of wrappers) {\n        if (wrapper.metatype === def.targetClass && wrapper.instance) {\n          const svc = new SingletonIntervalService(\n            def.key,\n            def.originalMethod,\n            def.interval,\n            def.options\n          );\n          svc.registerWithScheduler(wrapper.instance);\n          this.register(def.key, def.interval);\n        }\n      }\n    }\n    // Clear pending definitions\n    SingletonIntervalService.pendingDefinitions = [];\n\n    // Register static interval definitions\n    SingletonIntervalService.intervalDefinitions.forEach(\n      (interval: SingletonIntervalDefinition, intervalName: string) => {\n        this.register(intervalName, interval.interval);\n      }\n    );\n\n    // Flush pending registrations to scheduler\n    SingletonIntervalService.flushPendingRegistrations();\n\n    // Log unified list of all registered intervals\n    this.registry.forEach((record, key) =>\n      this.logger.log(\n        `Registered singleton interval: ${key} [${record.intervalMs}ms]`\n      )\n    );\n  }\n\n  /**\n   * Our in-memory store of interval records, keyed by `uniqueKey`.\n   * (e.g. \"MyService.myMethod\")\n   */\n  private readonly registry = new Map<string, IntervalRecord>();\n\n  /**\n   * Manually register an interval if desired.\n   * Some people prefer calling this from the decorator, but with event-based\n   * approach, you can also do it from a \"Started\" event if the record doesn't exist.\n   */\n  public register(uniqueKey: string, intervalMs: number): void {\n    if (!this.registry.has(uniqueKey)) {\n      this.registry.set(uniqueKey, {\n        intervalMs,\n        createTime: Date.now(),\n        lastStart: 0,\n        lastDuration: 0,\n        locked: false,\n      });\n    }\n  }\n\n  /**\n   * Get the raw record if you need it for debugging.\n   */\n  public getIntervalRecord(uniqueKey: string): IntervalRecord | undefined {\n    return this.registry.get(uniqueKey);\n  }\n\n  /**\n   * Produce a snapshot of all intervals' statuses for debugging or health checks.\n   */\n  public getStatusReport(): IntervalStatus[] {\n    const now = Date.now();\n    const results: IntervalStatus[] = [];\n\n    for (const [uniqueKey, record] of this.registry.entries()) {\n      const {\n        intervalMs,\n        createTime,\n        lastStart,\n        lastDuration,\n        locked,\n        lastError,\n        notMetConditions,\n        microservicesUnavailable,\n      } = record;\n\n      const conditionsNotMet = !!notMetConditions?.length;\n      const elapsedSinceStart = now - lastStart;\n      const elapsedSinceCreate = now - createTime;\n\n      let status: IntervalState;\n\n      if (!locked && lastStart === 0) {\n        // Never started\n        if (elapsedSinceCreate < intervalMs) {\n          status = IntervalState.INIT;\n        } else {\n          status = IntervalState.LATE;\n        }\n      } else if (locked) {\n        // Currently running\n        if (lastError) {\n          status = IntervalState.ERROR;\n        } else if (elapsedSinceStart <= intervalMs) {\n          status = IntervalState.RUNNING;\n        } else if (elapsedSinceStart <= intervalMs * 10) {\n          status = IntervalState.SLOW;\n        } else {\n          status = IntervalState.JAMMED;\n        }\n      } else {\n        // Not locked => has finished or is being skipped\n        if (microservicesUnavailable) {\n          status = IntervalState.MICROSERVICES_UNAVAILABLE;\n        } else if (conditionsNotMet) {\n          status = IntervalState.CONDITIONS_NOT_MET;\n        } else if (lastError) {\n          status = IntervalState.ERROR;\n        } else if (elapsedSinceStart <= intervalMs) {\n          status = IntervalState.HEALTHY;\n        } else if (elapsedSinceStart > intervalMs * 10) {\n          status = IntervalState.STOPPED;\n        } else {\n          status = IntervalState.HEALTHY;\n        }\n      }\n\n      results.push({\n        key: uniqueKey,\n        status,\n        locked,\n        lastDuration,\n        lastError,\n        notMetConditions,\n        microservicesUnavailable,\n      });\n    }\n\n    return results;\n  }\n\n  // ===========================================================================\n  // Event Listeners\n  // ---------------------------------------------------------------------------\n  @OnEvent(`**.${SingletonIntervalEvents.Started}`)\n  handleStarted(payload: {\n    intervalName: string;\n    intervalMs?: number;\n    timestamp: number;\n  }) {\n    const { intervalName } = payload;\n    const record = this.registry.get(intervalName)!;\n    record.lastStart = Date.now();\n    record.locked = true;\n    record.notMetConditions = undefined;\n    record.microservicesUnavailable = false;\n  }\n\n  @OnEvent(`**.${SingletonIntervalEvents.ConditionsNotMet}`)\n  handleConditionsNotMet(payload: {\n    intervalName: string;\n    failedConditions: string[];\n  }) {\n    const record = this.registry.get(payload.intervalName)!;\n    record.notMetConditions = payload.failedConditions;\n    record.locked = false;\n  }\n\n  @OnEvent(`**.${SingletonIntervalEvents.MicroservicesUnresponsive}`)\n  handleMicroservicesUnresponsive(payload: {\n    intervalName: string;\n    unresponsiveMicroservices: string[];\n  }) {\n    const record = this.registry.get(payload.intervalName)!;\n    record.microservicesUnavailable = true;\n    record.locked = false;\n  }\n\n  @OnEvent(`**.${SingletonIntervalEvents.Error}`)\n  handleError(payload: { intervalName: string; error: Error }) {\n    const record = this.registry.get(payload.intervalName)!;\n    record.lastError = payload.error;\n  }\n\n  @OnEvent(`**.${SingletonIntervalEvents.Success}`)\n  handleSuccess(payload: { intervalName: string; timestamp: number }) {\n    const record = this.registry.get(payload.intervalName)!;\n    record.lastError = undefined;\n  }\n\n  @OnEvent(`**.${SingletonIntervalEvents.Finish}`)\n  handleFinish(payload: {\n    intervalName: string;\n    timestamp: number;\n    elapsed?: number;\n  }) {\n    const record = this.registry.get(payload.intervalName)!;\n    record.lastDuration = payload.elapsed ?? 0;\n    record.locked = false;\n  }\n\n  @OnEvent(`**.${SingletonIntervalEvents.Terminated}`)\n  handleTerminated(payload: { intervalName: string; error: Error }) {\n    const record = this.registry.get(payload.intervalName)!;\n    record.lastError = payload.error;\n    record.locked = false;\n  }\n}\n"]}