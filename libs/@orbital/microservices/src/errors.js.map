{"version":3,"file":"errors.js","sourceRoot":"","sources":["errors.ts"],"names":[],"mappings":";;;AAAA,yDAAqD;AAErD;;GAEG;AACH,MAAa,4BAA6B,SAAQ,4BAAY;IAC5D,YAAY,OAAe,EAAE,KAAa;QACxC,KAAK,CAAC;YACJ,IAAI,EAAE,0BAA0B;YAChC,OAAO;YACP,OAAO,EAAE,GAAG,OAAO,iBAAiB;SACrC,CAAC,CAAC;QACH,IAAI,KAAK;YAAG,IAAY,CAAC,KAAK,GAAG,KAAK,CAAC;IACzC,CAAC;CACF;AATD,oEASC;AAED;;GAEG;AACH,MAAa,+BAAgC,SAAQ,4BAAY;IAC/D,YAAY,OAAe,EAAE,OAAe;QAC1C,KAAK,CAAC;YACJ,IAAI,EAAE,8BAA8B;YACpC,OAAO;YACP,OAAO;YACP,OAAO,EAAE,YAAY,OAAO,yBAAyB,OAAO,GAAG;SAChE,CAAC,CAAC;IACL,CAAC;CACF;AATD,0EASC;AAED;;;GAGG;AACH,MAAa,uBAAwB,SAAQ,4BAAY;IAKvD,YAAY,OAAe,EAAE,OAAe,EAAE,OAAY;QACxD,gEAAgE;QAChE,KAAK,CAAC;YACJ,IAAI,EAAE,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,IAAI,KAAI,2BAA2B;YAClD,OAAO;YACP,OAAO;YACP,OAAO,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,OAAO;YACzB,aAAa,EAAE,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,aAAa,KAAI,OAAO;SACjD,CAAC,CAAC;QAEH,wDAAwD;QACvD,IAAY,CAAC,KAAK,GAAG,OAAO,CAAC;QAC9B,IAAI,CAAC,aAAa,GAAG,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,aAAa,KAAI,OAAO,CAAC;QACvD,IAAI,CAAC,KAAK,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,KAAK,CAAC;QAC5B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;IAED;;OAEG;IACH,QAAQ;QACN,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;CACF;AA5BD,0DA4BC","sourcesContent":["import { RpcException } from \"@nestjs/microservices\";\n\n/**\n * Thrown when the target microservice is completely unavailable.\n */\nexport class MicroserviceUnavailableError extends RpcException {\n  constructor(service: string, cause?: Error) {\n    super({\n      code: \"MICROSERVICE_UNAVAILABLE\",\n      service,\n      message: `${service} is unavailable`,\n    });\n    if (cause) (this as any).cause = cause;\n  }\n}\n\n/**\n * Thrown when the microservice is up but no handler matches the requested pattern.\n */\nexport class UnrecognizedMessagePatternError extends RpcException {\n  constructor(service: string, pattern: string) {\n    super({\n      code: \"UNRECOGNIZED_MESSAGE_PATTERN\",\n      service,\n      pattern,\n      message: `Service '${service}' has no handler for '${pattern}'`,\n    });\n  }\n}\n\n/**\n * Thrown when the remote handler throws an unexpected error.\n * Preserves the remote stack trace in this.stack and the original error details.\n */\nexport class RemoteMicroserviceError extends RpcException {\n  readonly stack?: string;\n  readonly originalError?: any;\n  private readonly payload: any;\n\n  constructor(service: string, pattern: string, payload: any) {\n    // Pass through the entire payload to preserve all error details\n    super({\n      code: payload?.code || \"REMOTE_MICROSERVICE_ERROR\",\n      service,\n      pattern,\n      message: payload?.message,\n      originalError: payload?.originalError || payload,\n    });\n\n    // Store the original error for access by error handlers\n    (this as any).cause = payload;\n    this.originalError = payload?.originalError || payload;\n    this.stack = payload?.stack;\n    this.payload = payload;\n  }\n\n  /**\n   * Override the getError method to return the full payload\n   */\n  getError(): any {\n    return this.payload;\n  }\n}\n"]}