{"version":3,"file":"controller.decorator.js","sourceRoot":"","sources":["controller.decorator.ts"],"names":[],"mappings":";;AAcA,wDA8CC;AA5DD,4BAA0B;AAC1B,2CAAyD;AACzD,wDAA+E;AAE/E;;;;;;;;;GASG;AACH,SAAgB,sBAAsB,CAAC,WAAmB;IACxD,OAAO,CAAC,GAAG,CACT,gEAAgE,WAAW,EAAE,CAC9E,CAAC;IAEF,2EAA2E;IAC3E,OAAO,UAA8B,MAAS;QAC5C,MAAM,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC;QACnC,OAAO,CAAC,GAAG,CACT,kDAAkD,cAAc,EAAE,CACnE,CAAC;QAEF,wCAAwC;QACxC,IAAA,mBAAU,EAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;QAEvB,mDAAmD;QACnD,IAAA,oBAAW,EAAC,YAAY,EAAE,WAAW,CAAC,CAAC,MAAM,CAAC,CAAC;QAE/C,yEAAyE;QACzE,OAAO,CAAC,cAAc,CAAC,YAAY,EAAE,WAAW,EAAE,MAAM,CAAC,CAAC;QAC1D,OAAO,CAAC,cAAc,CAAC,YAAY,EAAE,WAAW,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC;QAEpE,oDAAoD;QACpD,OAAO,CAAC,cAAc,CAAC,gCAAoB,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;QAC3D,OAAO,CAAC,cAAc,CAAC,yBAAa,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;QAEnD,kCAAkC;QAClC,OAAO,CAAC,GAAG,CACT,oBAAoB,MAAM,CAAC,IAAI,eAAe,EAC9C,OAAO,CAAC,eAAe,CAAC,MAAM,CAAC,CAChC,CAAC;QACF,OAAO,CAAC,GAAG,CACT,oBAAoB,MAAM,CAAC,IAAI,aAAa,EAC5C,OAAO,CAAC,eAAe,CAAC,MAAM,CAAC,SAAS,CAAC,CAC1C,CAAC;QACF,OAAO,CAAC,GAAG,CACT,kCAAkC,EAClC,OAAO,CAAC,WAAW,CAAC,YAAY,EAAE,MAAM,CAAC,CAC1C,CAAC;QACF,OAAO,CAAC,GAAG,CACT,gCAAgC,EAChC,OAAO,CAAC,WAAW,CAAC,YAAY,EAAE,MAAM,CAAC,SAAS,CAAC,CACpD,CAAC;QAEF,OAAO,MAAM,CAAC;IAChB,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import \"reflect-metadata\";\nimport { Controller, SetMetadata } from \"@nestjs/common\";\nimport { PATH_METADATA, CONTROLLER_WATERMARK } from \"@nestjs/common/constants\";\n\n/**\n * Class decorator that marks a Nest controller as belonging to a specific microservice.\n * All @MessagePattern() methods inside will use this serviceName as prefix.\n *\n * This decorator applies the NestJS Controller decorator and then adds our custom metadata.\n *\n * Usage:\n *   @MicroserviceController(\"world\")\n *   export class AreasController { â€¦ }\n */\nexport function MicroserviceController(serviceName: string) {\n  console.log(\n    `Creating MicroserviceController decorator with service name: ${serviceName}`\n  );\n\n  // Create a custom decorator function that preserves the type of the target\n  return function <T extends Function>(target: T): T {\n    const controllerName = target.name;\n    console.log(\n      `MicroserviceController decorator executing for ${controllerName}`\n    );\n\n    // Apply the NestJS Controller decorator\n    Controller(\"\")(target);\n\n    // Set our custom metadata using NestJS SetMetadata\n    SetMetadata(\"ms:service\", serviceName)(target);\n\n    // Set metadata directly on both constructor and prototype for redundancy\n    Reflect.defineMetadata(\"ms:service\", serviceName, target);\n    Reflect.defineMetadata(\"ms:service\", serviceName, target.prototype);\n\n    // Ensure NestJS controller metadata is properly set\n    Reflect.defineMetadata(CONTROLLER_WATERMARK, true, target);\n    Reflect.defineMetadata(PATH_METADATA, \"/\", target);\n\n    // Log all metadata keys to verify\n    console.log(\n      `Metadata keys on ${target.name} constructor:`,\n      Reflect.getMetadataKeys(target)\n    );\n    console.log(\n      `Metadata keys on ${target.name} prototype:`,\n      Reflect.getMetadataKeys(target.prototype)\n    );\n    console.log(\n      `ms:service value on constructor:`,\n      Reflect.getMetadata(\"ms:service\", target)\n    );\n    console.log(\n      `ms:service value on prototype:`,\n      Reflect.getMetadata(\"ms:service\", target.prototype)\n    );\n\n    return target;\n  };\n}\n"]}