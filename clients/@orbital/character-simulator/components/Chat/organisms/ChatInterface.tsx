import { Alert, Box, Paper, Snackbar } from "@mui/material";
import { useEffect, useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { v4 as uuidv4 } from "uuid";
import {
  loadConversationThreads,
  saveConversationThreads,
  validateThreadName,
} from "../../../services/characterService";
import {
  ConversationThread,
  Message,
  RootState,
  addMessage,
  addThread,
  selectThread,
  setConversationThreads,
} from "../../../store";
import MessageInput from "../atoms/MessageInput";
import MessageList from "../molecules/MessageList";
import ThreadSelector from "../molecules/ThreadSelector";

interface ChatInterfaceProps {
  characterName: string;
}

const ChatInterface = ({ characterName }: ChatInterfaceProps) => {
  const dispatch = useDispatch();
  const { conversationThreads, selectedThreadId, selectedCharacterId } =
    useSelector((state: RootState) => state.character);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  // Load conversation threads when the component mounts
  useEffect(() => {
    if (selectedCharacterId) {
      setIsLoading(true);
      loadConversationThreads(selectedCharacterId)
        .then((threads) => {
          if (threads.length > 0) {
            dispatch(setConversationThreads(threads));
          } else {
            // Create a default thread if none exists
            const defaultThread: ConversationThread = {
              id: uuidv4(),
              name: "default",
              messages: [],
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
            };
            dispatch(addThread(defaultThread));
          }
        })
        .catch((err) => {
          console.error("Error loading conversation threads:", err);
          setError("Failed to load conversation threads");

          // Create a default thread if there's an error
          const defaultThread: ConversationThread = {
            id: uuidv4(),
            name: "default",
            messages: [],
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
          };
          dispatch(addThread(defaultThread));
        })
        .finally(() => {
          setIsLoading(false);
        });
    }
  }, [selectedCharacterId, dispatch]);

  // Save conversation threads when they change
  useEffect(() => {
    if (selectedCharacterId && conversationThreads.length > 0) {
      saveConversationThreads(selectedCharacterId, conversationThreads).catch(
        (err) => {
          console.error("Error saving conversation threads:", err);
          setError("Failed to save conversation threads");
        }
      );
    }
  }, [conversationThreads, selectedCharacterId]);

  // Get the selected thread
  const selectedThread = conversationThreads.find(
    (thread) => thread.id === selectedThreadId
  );

  // Handle thread selection
  const handleSelectThread = (threadId: string) => {
    dispatch(selectThread(threadId));
  };

  // Handle thread creation
  const handleCreateThread = (name: string) => {
    // Validate thread name
    if (!validateThreadName(name)) {
      setError(
        "Invalid thread name. Please use a valid name without special characters."
      );
      return;
    }

    const newThread: ConversationThread = {
      id: uuidv4(),
      name,
      messages: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    dispatch(addThread(newThread));
  };

  // Handle error snackbar close
  const handleCloseError = () => {
    setError(null);
  };

  // Handle sending a message
  const handleSendMessage = (content: string) => {
    if (!selectedThreadId) return;

    const userMessage: Message = {
      id: uuidv4(),
      content,
      sender: "user",
      timestamp: new Date().toISOString(),
    };

    dispatch(
      addMessage({
        threadId: selectedThreadId,
        message: userMessage,
      })
    );

    // Simulate character response (in a real app, this would be an API call)
    setTimeout(() => {
      const characterMessage: Message = {
        id: uuidv4(),
        content: `This is a simulated response from ${characterName}. In a real application, this would be generated by an API call.`,
        sender: "character",
        timestamp: new Date().toISOString(),
      };

      dispatch(
        addMessage({
          threadId: selectedThreadId,
          message: characterMessage,
        })
      );
    }, 1000);
  };

  return (
    <Paper elevation={0} sx={{ p: 0 }}>
      <Box sx={{ display: "flex", flexDirection: "column" }}>
        <ThreadSelector
          threads={conversationThreads}
          selectedThreadId={selectedThreadId}
          onSelectThread={handleSelectThread}
          onCreateThread={handleCreateThread}
          isLoading={isLoading}
        />

        <MessageList
          messages={selectedThread?.messages || []}
          characterName={characterName}
          isLoading={isLoading}
        />

        <MessageInput
          onSendMessage={handleSendMessage}
          disabled={!selectedThreadId || isLoading}
        />
      </Box>

      {/* Error Snackbar */}
      <Snackbar
        open={!!error}
        autoHideDuration={6000}
        onClose={handleCloseError}
        anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
      >
        <Alert onClose={handleCloseError} severity="error">
          {error}
        </Alert>
      </Snackbar>
    </Paper>
  );
};

export default ChatInterface;
