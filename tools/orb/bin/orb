#!/usr/bin/env node
import { program } from "commander";
import inquirer from "inquirer";
import { execSync } from "child_process";
import fs from "fs";
import path from "path";
import figlet from "figlet";
import { fileURLToPath } from "url";
import { createRequire } from "module";

const scriptPath = fileURLToPath(import.meta.url);

const __dirname = path.dirname(fileURLToPath(import.meta.url));
console.log(figlet.textSync("orb"));
const root = path.join(__dirname, "../../..");
const plopBin = path.join(root, "node_modules", ".bin", "plop");

// Default to interactive "manage" if no command provided
if (process.argv.length <= 2) {
  process.argv.push("manage");
}

function run(cmd, opts = {}) {
  execSync(cmd, { stdio: "inherit", ...opts });
}

program.version(
  JSON.parse(
    fs.readFileSync(path.join(__dirname, "../../../package.json"), "utf8")
  ).version
);

// Monorepo commands
const monorepoCmd = program
  .command("monorepo")
  .description("Manage monorepo commands");

monorepoCmd
  .command("install")
  .description("Install the monorepo-template remote")
  .action(() => {
    const remote = "monorepo-template";
    const url = "git@github.com:ArturMoczulski/orbital-monorepo-template.git";
    // ensure no duplicate remote
    try {
      run(`git remote remove ${remote}`, { stdio: "ignore" });
    } catch {}
    // add remote fresh
    run(`git remote add ${remote} ${url}`);
    console.log(`Added ${remote} remote pointing to ${url}`);
  });

monorepoCmd
  .command("update")
  .description("Update from monorepo-template remote")
  .action(() => {
    const remote = "monorepo-template";
    const url = "git@github.com:ArturMoczulski/orbital-monorepo-template.git";
    // ensure remote exists without printing errors if missing
    try {
      run(`git remote get-url ${remote}`, { stdio: "ignore" });
    } catch {
      run(`git remote add ${remote} ${url}`);
    }
    run(`git fetch ${remote} main`);
    run(`git merge ${remote}/main`);
    console.log("Monorepo updated from monorepo-template/main");
  });

monorepoCmd
  .command("test")
  .description("Run monorepo-template integration tests")
  .action(() => {
    run("jest --config jest.config.cjs");
  });

// Create project from template
program
  .command("create <category> <template> <name>")
  .description("Create a new project from a template non-interactively")
  .action((category, template, name) => {
    const projectRoot = process.cwd();
    const bases = { library: "libs", service: "services", client: "clients" };
    if (!bases[category]) {
      console.error(`Invalid category: ${category}`);
      process.exit(1);
    }
    // Scaffold project from static template
    const templateDir = path.join(projectRoot, "templates", template);
    const destDir = path.join(projectRoot, bases[category], name);
    fs.mkdirSync(destDir, { recursive: true });
    fs.cpSync(templateDir, destDir, { recursive: true });
    // Update package.json name field
    const pkgPath = path.join(destDir, "package.json");
    const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf8"));
    pkg.name = name.startsWith("@") ? name : `@orbital/${name}`;
    fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2));
  });

// Profile commands
const profileCmd = program
  .command("profile")
  .description("Profile related commands");

profileCmd
  .command("create <profileName>")
  .description("Create a new plop-based profile non-interactively")
  .action((profileName) => {
    const cleanName = profileName
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9-_]/g, "-");
    const projectRoot = process.cwd();
    const profilesRoot = path.join(projectRoot, "profiles");
    const profileSrcDir = path.join(
      root,
      "templates",
      "plop-profile",
      "profile"
    );
    const profileDestDir = path.join(profilesRoot, cleanName);
    fs.mkdirSync(profileDestDir, { recursive: true });
    fs.copyFileSync(
      path.join(root, "templates", "plop-profile", "plopfile.cjs"),
      path.join(profileDestDir, "plopfile.cjs")
    );
  });

// Interactive CLI
program
  .command("manage")
  .description("Launch interactive CLI")
  .action(async () => {
    while (true) {
      // Build main menu choices dynamically
      const baseDirs = ["libs", "services", "clients"];
      let hasProjects = false;
      for (const dir of baseDirs) {
        const dirPath = path.join(__dirname, "../../", dir);
        if (!fs.existsSync(dirPath)) continue;
        for (const entry of fs.readdirSync(dirPath)) {
          const projPath = path.join(dirPath, entry);
          if (
            fs.statSync(projPath).isDirectory() &&
            fs.existsSync(path.join(projPath, "package.json"))
          ) {
            hasProjects = true;
            break;
          }
        }
        if (hasProjects) break;
      }
      const mainChoices = ["Create project"];
      if (hasProjects) {
        mainChoices.push("Manage projects");
      }
      mainChoices.push("Create Profile");
      mainChoices.push("Manage monorepo", "Exit");
      const { choice } = await inquirer.prompt({
        type: "list",
        name: "choice",
        message: "Select an option:",
        choices: mainChoices,
      });

      if (choice === "Create project") {
        const answers = await inquirer.prompt([
          {
            type: "list",
            name: "category",
            message: "Select category:",
            choices: ["library", "service", "client"],
          },
          {
            type: "list",
            name: "template",
            message: "Select template:",
            choices: fs
              .readdirSync(path.join(__dirname, "../../../templates"))
              .filter((d) =>
                fs
                  .statSync(path.join(__dirname, "../../../templates", d))
                  .isDirectory()
              ),
          },
          {
            type: "input",
            name: "name",
            message: "Enter project name:",
          },
        ]);
        // use non-interactive create command for consistent scaffolding
        run(
          `node ${scriptPath} create ${answers.category} ${answers.template} ${answers.name}`,
          { stdio: "inherit" }
        );
        // After project creation, install dependencies at monorepo root
        run("yarn install", { cwd: path.join(__dirname, "../../..") });
        console.log("Project scaffolded and dependencies installed.");
      } else if (choice === "Create Profile") {
        const { profileName } = await inquirer.prompt({
          type: "input",
          name: "profileName",
          message: "Enter profile name:",
        });
        // use non-interactive profile create command
        run(`node ${scriptPath} profile create ${profileName}`, {
          stdio: "inherit",
        });
        console.log(`Profile '${profileName}' created.`);
      } else if (choice === "Manage projects") {
        // List all projects under libs, services, clients by package.json name
        const baseDirs = ["libs", "services", "clients"];
        const projects = [];
        for (const dir of baseDirs) {
          const dirPath = path.join(__dirname, "../../", dir);
          if (!fs.existsSync(dirPath)) continue;
          for (const entry of fs.readdirSync(dirPath)) {
            const projPath = path.join(dirPath, entry);
            if (fs.statSync(projPath).isDirectory()) {
              const pkgPath = path.join(projPath, "package.json");
              if (fs.existsSync(pkgPath)) {
                const { name: pkgName } = JSON.parse(
                  fs.readFileSync(pkgPath, "utf8")
                );
                projects.push({ name: pkgName, path: projPath });
              }
            }
          }
        }
        const choices = projects
          .map((p) => p.name)
          .concat(new inquirer.Separator(), "Go back");
        const { projectName } = await inquirer.prompt({
          type: "list",
          name: "projectName",
          message: "Select project:",
          choices,
        });
        if (projectName === "Go back") continue;
        const project = projects.find((p) => p.name === projectName);
        // select project action
        const { projectAction } = await inquirer.prompt({
          type: "list",
          name: "projectAction",
          message: "Select project action:",
          choices: ["Update env var", "Add profiles", "Go back"],
        });
        if (projectAction === "Go back") continue;
        if (projectAction === "Add profiles") {
          const profilesDir = path.join(__dirname, "../../../profiles");
          if (!fs.existsSync(profilesDir)) {
            console.error("No profiles directory found.");
            continue;
          }
          const available = fs
            .readdirSync(profilesDir)
            .filter((f) =>
              fs.statSync(path.join(profilesDir, f)).isDirectory()
            );
          const { profiles } = await inquirer.prompt({
            type: "checkbox",
            name: "profiles",
            message: "Select profiles to apply:",
            choices: available,
          });
          for (const prof of profiles) {
            run(`node ${scriptPath} add-profile ${projectName} ${prof}`, {
              cwd: project.path,
            });
          }
          continue;
        }
        // default: Update env var
        const envPath = path.join(project.path, ".env.template");
        if (!fs.existsSync(envPath)) fs.writeFileSync(envPath, "");
        const envContent = fs.readFileSync(envPath, "utf8").split(/\r?\n/);
        const { key, value } = await inquirer.prompt([
          {
            type: "input",
            name: "key",
            message: "Enter environment variable name:",
          },
          { type: "input", name: "value", message: "Enter value:" },
        ]);
        const idx = envContent.findIndex((line) => line.startsWith(`${key}=`));
        if (idx >= 0) envContent[idx] = `${key}=${value}`;
        else envContent.push(`${key}=${value}`);
        fs.writeFileSync(envPath, envContent.join("\n"));
        console.log(`Updated ${key} in ${envPath}`);
      } else if (choice === "Manage monorepo") {
        const { action } = await inquirer.prompt({
          type: "list",
          name: "action",
          message: "Select action:",
          choices: [
            "Install template remote",
            "Update from template",
            "Run monorepo tests",
            "Go back",
          ],
        });
        if (action === "Install template remote")
          run("node bin/tools/orb monorepo install");
        else if (action === "Update from template")
          run("node bin/tools/orb monorepo update");
        else if (action === "Run monorepo tests")
          run("node bin/tools/orb monorepo test");
        else if (action === "Go back") continue;
      } else {
        process.exit(0);
      }
    }
  });

// Non-interactive add-profile command
program
  .command("add-profile <projectName> [profiles...]")
  .description(
    "Add one or more plop-based profiles to a project non-interactively"
  )
  .action((projectName, profiles) => {
    const baseDirs = ["libs", "services", "clients"];
    const projects = [];
    for (const dir of baseDirs) {
      const dirPath = path.join(__dirname, "../../", dir);
      if (!fs.existsSync(dirPath)) continue;
      for (const entry of fs.readdirSync(dirPath)) {
        const projPath = path.join(dirPath, entry);
        const pkgPath = path.join(projPath, "package.json");
        if (fs.existsSync(pkgPath)) {
          const { name } = JSON.parse(fs.readFileSync(pkgPath, "utf8"));
          projects.push({ name, path: projPath });
        }
      }
    }
    const project = projects.find((p) => p.name === projectName);
    if (!project) {
      console.error(`Project not found: ${projectName}`);
      process.exit(1);
    }
    const profilesDir = path.join(__dirname, "../../../profiles");
    for (const prof of profiles || []) {
      const profDir = path.join(profilesDir, prof);
      if (!fs.existsSync(profDir)) {
        console.error(`Profile not found: ${prof}`);
        process.exit(1);
      }
      run(`yarn plop ${prof}`, { cwd: project.path });
      console.log(`Applied profile ${prof} to ${projectName}`);
    }
  });

program.parse(process.argv);
